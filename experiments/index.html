<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">community.qiskit.org</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="true" data-hid="description" name="description" content="Home of the Qiskit Community"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" href="/_nuxt/e4a6c8f96de9b22b1fd1.js" as="script"><link rel="preload" href="/_nuxt/33a95c28e8058ed027ee.js" as="script"><link rel="preload" href="/_nuxt/6c5b5dda30dfc24b2273.js" as="script"><link rel="preload" href="/_nuxt/f4970d7ed49cd7da99d4.js" as="script"><link rel="preload" href="/_nuxt/53e5ca4e26d8f84797b2.js" as="script"><style data-vue-ssr-id="17cfdfa9:0 85741a28:0 44826512:0 25c55dba:0 4dbac29b:0 730e73d2:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#fff;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}@font-face{font-family:IBM Plex Mono;font-style:normal;font-weight:400;src:local("IBM Plex Mono"),local("IBMPlexMono"),url(/fonts/IBM-Plex-Mono/fonts/complete/woff/IBMPlexMono-Regular.woff) format("woff")}@font-face{font-family:IBM Plex Mono;font-style:italic;font-weight:400;src:local("IBM Plex Mono Italic"),local("IBMPlexMono-Italic"),url(/fonts/IBM-Plex-Mono/fonts/complete/woff/IBMPlexMono-Italic.woff) format("woff")}@font-face{font-family:IBM Plex Sans;font-style:normal;font-weight:400;src:local("IBM Plex Sans"),local("IBMPlexSans"),url(/fonts/IBM-Plex-Sans/fonts/complete/woff/IBMPlexSans-Regular.woff) format("woff")}:root{--secondary-color:#673ab7;--dark-color:#1e143c;--gray-color:rgba(71,71,71,0.9);--shadow-color:#949494;--ibm-blue:#0a1d8f}*{margin:0;padding:0}html{font-family:IBM Plex Sans,sans-serif;font-size:18px;background-image:url(/images/events/deco/dots.svg),url(/images/events/deco/dots.svg),url(/images/events/deco/dots.svg),url(/images/events/deco/lines.svg),url(/images/events/deco/lines.svg),url(/images/events/deco/lines.svg);background-repeat:repeat-x,repeat-x,repeat-x,repeat-y,repeat-y,repeat-y;background-position:top calc(100vh + 890px) left 0,top calc(100vh + 930px) left 0,top calc(100vh + 970px) left 0,top 0 right 100px,top 0 right 0,top 0 right -100px}ul{margin:1rem 0 1rem 3rem}a{text-decoration:none;color:#4a90e2}a:hover{opacity:.6}h2:before{content:"";float:left;width:5%;margin-top:.5rem;margin-right:5%;border-top:1px solid #0a1d8f;border-top:1px solid var(--ibm-blue)}h2{margin:2rem 0 2.5rem;color:#0a1d8f;color:var(--ibm-blue)}.wrapper{display:flex;flex-direction:column}.logo[data-v-0e40e6d0]{width:1.7rem;margin-top:-.2rem;margin-right:.2rem;vertical-align:middle}.ibm-research[data-v-0e40e6d0]{position:fixed;left:5%;z-index:101}.ibm-research a[data-v-0e40e6d0]{margin:0;padding-top:.2rem;display:inline-block;border-top:4px solid #000;font-size:1.7rem;color:#000}nav[data-v-0e40e6d0]{justify-content:center;width:100%;position:fixed;top:0;z-index:100;box-shadow:0 0 16px #2b2b2b;background-color:#fff;min-height:63px}nav ul[data-v-0e40e6d0],nav[data-v-0e40e6d0]{display:flex;flex-wrap:wrap}nav ul[data-v-0e40e6d0]{margin:0;justify-content:flex-end;align-items:center}nav li[data-v-0e40e6d0],nav ul[data-v-0e40e6d0]{height:100%;list-style:none}nav li[data-v-0e40e6d0]{font-weight:700;text-indent:0;margin:0 .8rem;line-height:3.5rem;cursor:pointer}nav li:hover a[data-v-0e40e6d0]{opacity:.6;border-bottom:2px solid #0a1d8f}nav li.active a[data-v-0e40e6d0],nav li.active:hover a[data-v-0e40e6d0]{opacity:.6;border:none}nav li a[data-v-0e40e6d0]{color:#000}.convertible-menu[data-v-0e40e6d0]{display:block;position:relative;align-self:center;width:100%;z-index:1}.convertible-menu .hamburger[data-v-0e40e6d0]{display:none;margin-left:calc(100% - 40px - 1rem)}.convertible-menu input[data-v-0e40e6d0]{display:block;width:40px;height:32px;position:absolute;top:-7px;left:-5px;cursor:pointer;opacity:0;z-index:2}.convertible-menu span[data-v-0e40e6d0]{display:block;width:33px;height:4px;margin-bottom:5px;border-radius:3px;position:relative;z-index:1;background-color:#cdcdcd;transform-origin:4px 0;transition:transform .5s cubic-bezier(.77,.2,.05,1),background .5s cubic-bezier(.77,.2,.05,1),opacity .55s ease}.convertible-menu input:checked~span[data-v-0e40e6d0]{opacity:1;transform:rotate(45deg) translateY(-1px);background:#232323}.convertible-menu input:checked~span[data-v-0e40e6d0]:nth-last-child(3){opacity:0;transform:rotate(0) scale(.2)}.convertible-menu input:checked~span[data-v-0e40e6d0]:nth-last-child(2){opacity:1;transform:rotate(-45deg) translate(-1px,-2px);background:#232323}@media (max-width:800px){.convertible-menu .hamburger[data-v-0e40e6d0]{display:block}.convertible-menu ul[data-v-0e40e6d0]{text-align:right;width:100vw;position:absolute;background-color:#fff;display:block;height:auto;border-bottom:1px solid #0a1d8f;transition:transform .5s cubic-bezier(.77,.2,.05,1);transform:translateX(100%)}.convertible-menu input:checked~ul[data-v-0e40e6d0]{transform:translateX(0)}.convertible-menu ul li[data-v-0e40e6d0]{padding-right:2.5%}.id-stub[data-v-0e40e6d0]{top:-380px}}main{position:relative;top:60px}.content{margin-left:10%;margin-right:10%;max-width:100rem}.featured .experiment{border:1px solid #ccc;box-shadow:0 0 2rem 0 rgba(0,0,0,.2);max-width:40rem}.featured .experiment:hover{box-shadow:0 0 1rem 0 rgba(0,0,0,.4)}.collection{display:grid;grid-gap:.4rem;grid-template-columns:repeat(auto-fit,20rem);grid-auto-flow:row}.collection .experiment{box-sizing:border-box;min-height:20rem;min-width:20rem;max-width:20rem;max-height:20rem;border:1px solid var(--ibm-blue)}@media (max-width:500px){.collection{display:block}.collection .experiment{min-height:auto;min-width:auto;max-width:auto;max-height:auto;margin-bottom:.5rem}}.experiment[data-v-fed68718]{position:relative;transition:box-shadow .2s;background-position:100% 0;background-size:cover;font-size:.9rem;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-end;background-color:#fff;background-color:var(--secondary-color,#fff)}.experiment[small][data-v-fed68718]{min-height:7.5rem}.experiment>a[data-v-fed68718]{color:#000;position:absolute;top:0;bottom:0;right:0;left:0}.experiment>a[data-v-fed68718]:hover{opacity:1}.experiment h3[data-v-fed68718]{padding:0 1rem;margin:1rem 0 0;background-color:#fff;display:inline-block}.experiment h3[data-v-fed68718]:last-child{padding-bottom:1rem}.experiment .author[data-v-fed68718]{color:grey;padding-bottom:0}.experiment section[data-v-fed68718]{background-color:hsla(0,0%,100%,.9);padding:1rem;align-self:stretch}.stump[data-v-fed68718]{min-height:5rem}[major] .stump[data-v-fed68718]{min-height:15rem}footer[data-v-32122a48]{color:#fff;display:flex;flex-direction:column;justify-content:center;min-height:10rem;text-align:center;margin-top:4rem;background-color:var(--dark-color)}</style>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav data-v-0e40e6d0><section class="ibm-research" data-v-0e40e6d0><a href="https://qiskit.org" target="_blank" rel="noopener" class="text-logo" data-v-0e40e6d0><img alt="Qiskit logo" src="https://qiskit.camp/img/qiskit-logo.png" class="logo" data-v-0e40e6d0>Â Qiskit</a></section> <div class="convertible-menu" data-v-0e40e6d0><input type="checkbox" class="hamburger" data-v-0e40e6d0> <span class="hamburger" data-v-0e40e6d0></span> <span class="hamburger" data-v-0e40e6d0></span> <span class="hamburger" data-v-0e40e6d0></span> <ul data-v-0e40e6d0></ul></div></nav> <main><section><h2>
      Featured Experiment
    </h2> <div class="content featured"><article major="" class="experiment" style="background-image:url(https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png)" data-v-fed68718><a href="/experiments/qiskit-blocks" target="_self" rel="noopener" data-v-fed68718></a> <div class="stump" data-v-fed68718></div> <h3 data-v-fed68718>
    Qiskit Blocks
  </h3> <section class="author" data-v-fed68718>
    by James Weaver
  </section> <section data-v-fed68718>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.</section></article></div></section> <section><h2>
      Qiskit Experiments
    </h2> <div class="content collection"><article major="" class="experiment" style="background-image:url(/images/experiments/qonway-game-of-life/featured.jpeg)" data-v-fed68718><a href="/experiments/qonway-game-of-life" target="_self" rel="noopener" data-v-fed68718></a> <div class="stump" data-v-fed68718></div> <h3 data-v-fed68718>
    Qonway Game of Life
  </h3> <section class="author" data-v-fed68718>
    by Daniel Bultrini, Enrique de la Torre and Xiang Nan
  </section> <section data-v-fed68718>A reinterpretation of the classical Conway Game of Life by incorporating quantum physics to the rules and speeding up new state generation.</section></article><article major="" class="experiment" style="background-image:url(https://raw.githubusercontent.com/JavaFXpert/quantum-toy-piano-ibmq/master/docimages/performance-tab.png)" data-v-fed68718><a href="/experiments/quantum-toy-piano" target="_self" rel="noopener" data-v-fed68718></a> <div class="stump" data-v-fed68718></div> <h3 data-v-fed68718>
    Quantum Toy Piano
  </h3> <section class="author" data-v-fed68718>
    by James Weaver
  </section> <section data-v-fed68718>The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator.</section></article><article major="" class="experiment" style="background-image:url(/images/experiments/tictacq/basic-player.png)" data-v-fed68718><a href="/experiments/tictacq" target="_self" rel="noopener" data-v-fed68718></a> <div class="stump" data-v-fed68718></div> <h3 data-v-fed68718>
    TicTacQ
  </h3> <section class="author" data-v-fed68718>
    by Maddy Tod
  </section> <section data-v-fed68718>Play TicTacToe against a quantum computer, which can use 3 different strategies to try and win.</section></article><article major="" class="experiment" style="background-image:url(https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png)" data-v-fed68718><a href="/experiments/qiskit-blocks" target="_self" rel="noopener" data-v-fed68718></a> <div class="stump" data-v-fed68718></div> <h3 data-v-fed68718>
    Qiskit Blocks
  </h3> <section class="author" data-v-fed68718>
    by James Weaver
  </section> <section data-v-fed68718>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.</section></article></div></section></main> <footer data-v-32122a48><p data-v-32122a48>Copyright IBM Corp. 2018-2019</p></footer></div></div></div><script>window.__NUXT__=function(e){return{layout:"secondary",data:[{sections:[{title:"Featured Experiment",basepath:e,collections:{cards:[Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\n\n",html:"<p>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description</p>\n",attributes:{title:"Qiskit Blocks",author:"James Weaver",description:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.",image:"https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png",to:"/experiments/qiskit-blocks",media:["https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png","/images/experiments/qiskit-blocks/quantum_cats_sandbox.png"],source:"https://github.com/JavaFXpert/QiskitBlocks",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qiskit-blocks.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:"return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('p',[_vm._v(\"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\")])]) }]",component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\n\n"},html:{writable:!0,enumerable:!0,value:"<p>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description</p>\n"},attributes:{writable:!0,enumerable:!0,value:{title:"Qiskit Blocks",author:"James Weaver",description:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.",image:"https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png",to:"/experiments/qiskit-blocks",media:["https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png","/images/experiments/qiskit-blocks/quantum_cats_sandbox.png"],source:"https://github.com/JavaFXpert/QiskitBlocks",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qiskit-blocks.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:"return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('p',[_vm._v(\"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\")])]) }]",component:{data:{},render:{},created:{}}}}})]}},{title:"Qiskit Experiments",basepath:e,collections:{cards:[Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:"These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.\n\nContinous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).\n\n## 1D Quantum Game of Life\n\nIn this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1>), dead (|0>) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:\n* The resulting circuit was (as you can see above) huge\n* The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually **corrupted** the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid.",html:'<p>These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.</p>\n<p>Continous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).</p>\n<h2 id="1d-quantum-game-of-life">1D Quantum Game of Life</h2>\n<p>In this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1&gt;), dead (|0&gt;) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:</p>\n<ul>\n<li>The resulting circuit was (as you can see above) huge</li>\n<li>The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually <strong>corrupted</strong> the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid.</li>\n</ul>\n',attributes:{title:"Qonway Game of Life",author:"Daniel Bultrini, Enrique de la Torre and Xiang Nan",description:"A reinterpretation of the classical Conway Game of Life by incorporating quantum physics to the rules and speeding up new state generation.",image:"/images/experiments/qonway-game-of-life/featured.jpeg",to:"/experiments/qonway-game-of-life",media:["https://raw.githubusercontent.com/qonwaygameoflife/qonwaygameoflife/master/images/life.jpeg","https://raw.githubusercontent.com/qonwaygameoflife/qonwaygameoflife/master/images/onedgameoflife.jpeg"],source:"https://github.com/qonwaygameoflife/qonwaygameoflife",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qonway-game-of-life.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.")]),_vm._v(" "),_c(\'p\',[_vm._v("Continous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"1d-quantum-game-of-life"}},[_vm._v("1D Quantum Game of Life")]),_vm._v(" "),_c(\'p\',[_vm._v("In this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1>), dead (|0>) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("The resulting circuit was (as you can see above) huge")]),_vm._v(" "),_c(\'li\',[_vm._v("The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually "),_c(\'strong\',[_vm._v("corrupted")]),_vm._v(" the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid.")])])]) }]',component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:"These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.\n\nContinous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).\n\n## 1D Quantum Game of Life\n\nIn this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1>), dead (|0>) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:\n* The resulting circuit was (as you can see above) huge\n* The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually **corrupted** the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid."},html:{writable:!0,enumerable:!0,value:'<p>These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.</p>\n<p>Continous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).</p>\n<h2 id="1d-quantum-game-of-life">1D Quantum Game of Life</h2>\n<p>In this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1&gt;), dead (|0&gt;) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:</p>\n<ul>\n<li>The resulting circuit was (as you can see above) huge</li>\n<li>The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually <strong>corrupted</strong> the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid.</li>\n</ul>\n'},attributes:{writable:!0,enumerable:!0,value:{title:"Qonway Game of Life",author:"Daniel Bultrini, Enrique de la Torre and Xiang Nan",description:"A reinterpretation of the classical Conway Game of Life by incorporating quantum physics to the rules and speeding up new state generation.",image:"/images/experiments/qonway-game-of-life/featured.jpeg",to:"/experiments/qonway-game-of-life",media:["https://raw.githubusercontent.com/qonwaygameoflife/qonwaygameoflife/master/images/life.jpeg","https://raw.githubusercontent.com/qonwaygameoflife/qonwaygameoflife/master/images/onedgameoflife.jpeg"],source:"https://github.com/qonwaygameoflife/qonwaygameoflife",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qonway-game-of-life.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("These are three renditions of the quantum game of life - top left is the classical game of life, top right is the semi quantum version\\nand the bottom is a fully quantum kernel rendition. The fully quantum kernel uses a quantum cloning machine to bring cells to life as an average of the neighbouring cells.")]),_vm._v(" "),_c(\'p\',[_vm._v("Continous boundary conditions! And you can draw live cells! (draw on the top left classical game and the new cells will be replicated to the other 2).")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"1d-quantum-game-of-life"}},[_vm._v("1D Quantum Game of Life")]),_vm._v(" "),_c(\'p\',[_vm._v("In this case, instead of a 2D board to code the Game of Life, we use a 1D quantum register. By putting the qubits in different states as if they were cells: alive (|1>), dead (|0>) or neither alive nor dead (superposition), the idea was to produce all possible results by sequentially applying the same Truth Table Oracle which coded the dead/alive rules. However:")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("The resulting circuit was (as you can see above) huge")]),_vm._v(" "),_c(\'li\',[_vm._v("The output of an oracle was inputted in the next one but, it is likely, that by doing so we were also propagating an unintended phase change that eventually "),_c(\'strong\',[_vm._v("corrupted")]),_vm._v(" the results. With 4 or more input qubits, the outputs of the second oracle were no longer valid.")])])]) }]',component:{data:{},render:{},created:{}}}}}),Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:"The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical *composition* consists of a series of quantum circuits. Each quantum musical tone [[1]](#references) in the *performance* of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.\n\n## Creating a quantum musical composition\n\nTo create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch *melodically*. Take a moment to examine the music score in Fig. 1 and notice that the staff labeled **Melody** contains an eight-note melody. Please also realize that the staff labeled **Harmony** actually contains seven four-note melodies.  Users enter their desired probabilities into the [doubly-stochastic matrix](https://en.wikipedia.org/wiki/Doubly_stochastic_matrix) located on the left side of the **MELODY MATRICES** tab.\n\nClicking the **Optimize Rotations** button updates the [orthogonal matrix](https://en.wikipedia.org/wiki/Orthogonal_matrix) on the right to contain values, that when squared, comprise a [unistochastic matrix](https://en.wikipedia.org/wiki/Unistochastic_matrix) that approximates the user's desired probabilities. Deselecting and selecting the **Show Probabilities** checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the **Degree of Freedom Rotations** region of this tab. Each slider has the range ![eqn_range_0_pi2](docimages/eqn_range_0_pi2.gif) radians.\n\nTo continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played *harmonically* with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled **Melody** have a note in the staff labeled **Harmony** directly above it. Users enter their desired probabilities into the [doubly-stochastic matrix](https://en.wikipedia.org/wiki/Doubly_stochastic_matrix) located on the left side of the **HARMONY MATRICES** tab, and then click the **Optimize Rotations** button.\n\nThe harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same [pitch class](https://en.wikipedia.org/wiki/Pitch_class) as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren't determined by the quantum computer.\n",html:'<p>The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical <em>composition</em> consists of a series of quantum circuits. Each quantum musical tone <a href="#references">[1]</a> in the <em>performance</em> of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.</p>\n<h2 id="creating-a-quantum-musical-composition">Creating a quantum musical composition</h2>\n<p>To create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch <em>melodically</em>. Take a moment to examine the music score in Fig. 1 and notice that the staff labeled <strong>Melody</strong> contains an eight-note melody. Please also realize that the staff labeled <strong>Harmony</strong> actually contains seven four-note melodies.  Users enter their desired probabilities into the <a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix" target="_blank" rel="noopener">doubly-stochastic matrix</a> located on the left side of the <strong>MELODY MATRICES</strong> tab.</p>\n<p>Clicking the <strong>Optimize Rotations</strong> button updates the <a href="https://en.wikipedia.org/wiki/Orthogonal_matrix" target="_blank" rel="noopener">orthogonal matrix</a> on the right to contain values, that when squared, comprise a <a href="https://en.wikipedia.org/wiki/Unistochastic_matrix" target="_blank" rel="noopener">unistochastic matrix</a> that approximates the user\'s desired probabilities. Deselecting and selecting the <strong>Show Probabilities</strong> checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the <strong>Degree of Freedom Rotations</strong> region of this tab. Each slider has the range <img src="docimages/eqn_range_0_pi2.gif" alt="eqn_range_0_pi2"> radians.</p>\n<p>To continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played <em>harmonically</em> with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled <strong>Melody</strong> have a note in the staff labeled <strong>Harmony</strong> directly above it. Users enter their desired probabilities into the <a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix" target="_blank" rel="noopener">doubly-stochastic matrix</a> located on the left side of the <strong>HARMONY MATRICES</strong> tab, and then click the <strong>Optimize Rotations</strong> button.</p>\n<p>The harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same <a href="https://en.wikipedia.org/wiki/Pitch_class" target="_blank" rel="noopener">pitch class</a> as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren\'t determined by the quantum computer.</p>\n',attributes:{title:"Quantum Toy Piano",author:"James Weaver",description:"The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator.",image:"https://raw.githubusercontent.com/JavaFXpert/quantum-toy-piano-ibmq/master/docimages/performance-tab.png",to:"/experiments/quantum-toy-piano",media:["/video/qiskit-camp-community.mp4","https://raw.githubusercontent.com/JavaFXpert/quantum-toy-piano-ibmq/master/docimages/performance-tab.png","/images/experiments/quantum-toy-piano/third-species-performance.png"],launch:"https://quantum-toy-piano.herokuapp.com/static/index.html",source:"https://github.com/JavaFXpert/quantum-toy-piano-ibmq",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/quantum-toy-piano.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical "),_c(\'em\',[_vm._v("composition")]),_vm._v(" consists of a series of quantum circuits. Each quantum musical tone "),_c(\'a\',{attrs:{"href":"#references"}},[_vm._v("[1]")]),_vm._v(" in the "),_c(\'em\',[_vm._v("performance")]),_vm._v(" of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"creating-a-quantum-musical-composition"}},[_vm._v("Creating a quantum musical composition")]),_vm._v(" "),_c(\'p\',[_vm._v("To create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch "),_c(\'em\',[_vm._v("melodically")]),_vm._v(". Take a moment to examine the music score in Fig. 1 and notice that the staff labeled "),_c(\'strong\',[_vm._v("Melody")]),_vm._v(" contains an eight-note melody. Please also realize that the staff labeled "),_c(\'strong\',[_vm._v("Harmony")]),_vm._v(" actually contains seven four-note melodies.  Users enter their desired probabilities into the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Doubly_stochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("doubly-stochastic matrix")]),_vm._v(" located on the left side of the "),_c(\'strong\',[_vm._v("MELODY MATRICES")]),_vm._v(" tab.")]),_vm._v(" "),_c(\'p\',[_vm._v("Clicking the "),_c(\'strong\',[_vm._v("Optimize Rotations")]),_vm._v(" button updates the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Orthogonal_matrix","target":"_blank","rel":"noopener"}},[_vm._v("orthogonal matrix")]),_vm._v(" on the right to contain values, that when squared, comprise a "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Unistochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("unistochastic matrix")]),_vm._v(" that approximates the user\'s desired probabilities. Deselecting and selecting the "),_c(\'strong\',[_vm._v("Show Probabilities")]),_vm._v(" checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the "),_c(\'strong\',[_vm._v("Degree of Freedom Rotations")]),_vm._v(" region of this tab. Each slider has the range "),_c(\'img\',{attrs:{"src":"docimages/eqn_range_0_pi2.gif","alt":"eqn_range_0_pi2"}}),_vm._v(" radians.")]),_vm._v(" "),_c(\'p\',[_vm._v("To continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played "),_c(\'em\',[_vm._v("harmonically")]),_vm._v(" with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled "),_c(\'strong\',[_vm._v("Melody")]),_vm._v(" have a note in the staff labeled "),_c(\'strong\',[_vm._v("Harmony")]),_vm._v(" directly above it. Users enter their desired probabilities into the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Doubly_stochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("doubly-stochastic matrix")]),_vm._v(" located on the left side of the "),_c(\'strong\',[_vm._v("HARMONY MATRICES")]),_vm._v(" tab, and then click the "),_c(\'strong\',[_vm._v("Optimize Rotations")]),_vm._v(" button.")]),_vm._v(" "),_c(\'p\',[_vm._v("The harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Pitch_class","target":"_blank","rel":"noopener"}},[_vm._v("pitch class")]),_vm._v(" as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren\'t determined by the quantum computer.")])]) }]',component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:"The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical *composition* consists of a series of quantum circuits. Each quantum musical tone [[1]](#references) in the *performance* of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.\n\n## Creating a quantum musical composition\n\nTo create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch *melodically*. Take a moment to examine the music score in Fig. 1 and notice that the staff labeled **Melody** contains an eight-note melody. Please also realize that the staff labeled **Harmony** actually contains seven four-note melodies.  Users enter their desired probabilities into the [doubly-stochastic matrix](https://en.wikipedia.org/wiki/Doubly_stochastic_matrix) located on the left side of the **MELODY MATRICES** tab.\n\nClicking the **Optimize Rotations** button updates the [orthogonal matrix](https://en.wikipedia.org/wiki/Orthogonal_matrix) on the right to contain values, that when squared, comprise a [unistochastic matrix](https://en.wikipedia.org/wiki/Unistochastic_matrix) that approximates the user's desired probabilities. Deselecting and selecting the **Show Probabilities** checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the **Degree of Freedom Rotations** region of this tab. Each slider has the range ![eqn_range_0_pi2](docimages/eqn_range_0_pi2.gif) radians.\n\nTo continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played *harmonically* with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled **Melody** have a note in the staff labeled **Harmony** directly above it. Users enter their desired probabilities into the [doubly-stochastic matrix](https://en.wikipedia.org/wiki/Doubly_stochastic_matrix) located on the left side of the **HARMONY MATRICES** tab, and then click the **Optimize Rotations** button.\n\nThe harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same [pitch class](https://en.wikipedia.org/wiki/Pitch_class) as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren't determined by the quantum computer.\n"},html:{writable:!0,enumerable:!0,value:'<p>The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical <em>composition</em> consists of a series of quantum circuits. Each quantum musical tone <a href="#references">[1]</a> in the <em>performance</em> of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.</p>\n<h2 id="creating-a-quantum-musical-composition">Creating a quantum musical composition</h2>\n<p>To create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch <em>melodically</em>. Take a moment to examine the music score in Fig. 1 and notice that the staff labeled <strong>Melody</strong> contains an eight-note melody. Please also realize that the staff labeled <strong>Harmony</strong> actually contains seven four-note melodies.  Users enter their desired probabilities into the <a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix" target="_blank" rel="noopener">doubly-stochastic matrix</a> located on the left side of the <strong>MELODY MATRICES</strong> tab.</p>\n<p>Clicking the <strong>Optimize Rotations</strong> button updates the <a href="https://en.wikipedia.org/wiki/Orthogonal_matrix" target="_blank" rel="noopener">orthogonal matrix</a> on the right to contain values, that when squared, comprise a <a href="https://en.wikipedia.org/wiki/Unistochastic_matrix" target="_blank" rel="noopener">unistochastic matrix</a> that approximates the user\'s desired probabilities. Deselecting and selecting the <strong>Show Probabilities</strong> checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the <strong>Degree of Freedom Rotations</strong> region of this tab. Each slider has the range <img src="docimages/eqn_range_0_pi2.gif" alt="eqn_range_0_pi2"> radians.</p>\n<p>To continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played <em>harmonically</em> with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled <strong>Melody</strong> have a note in the staff labeled <strong>Harmony</strong> directly above it. Users enter their desired probabilities into the <a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix" target="_blank" rel="noopener">doubly-stochastic matrix</a> located on the left side of the <strong>HARMONY MATRICES</strong> tab, and then click the <strong>Optimize Rotations</strong> button.</p>\n<p>The harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same <a href="https://en.wikipedia.org/wiki/Pitch_class" target="_blank" rel="noopener">pitch class</a> as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren\'t determined by the quantum computer.</p>\n'},attributes:{writable:!0,enumerable:!0,value:{title:"Quantum Toy Piano",author:"James Weaver",description:"The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator.",image:"https://raw.githubusercontent.com/JavaFXpert/quantum-toy-piano-ibmq/master/docimages/performance-tab.png",to:"/experiments/quantum-toy-piano",media:["/video/qiskit-camp-community.mp4","https://raw.githubusercontent.com/JavaFXpert/quantum-toy-piano-ibmq/master/docimages/performance-tab.png","/images/experiments/quantum-toy-piano/third-species-performance.png"],launch:"https://quantum-toy-piano.herokuapp.com/static/index.html",source:"https://github.com/JavaFXpert/quantum-toy-piano-ibmq",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/quantum-toy-piano.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("The Quantum Music Composer application enables a user to compose music that is performed by a quantum computer or quantum simulator. The musical "),_c(\'em\',[_vm._v("composition")]),_vm._v(" consists of a series of quantum circuits. Each quantum musical tone "),_c(\'a\',{attrs:{"href":"#references"}},[_vm._v("[1]")]),_vm._v(" in the "),_c(\'em\',[_vm._v("performance")]),_vm._v(" of a composition is a quantum state, which when measured, results in a pitch determined by quantum mechanical behavior. This normally results in unique melodies and harmonies each time a given composition is performed by a quantum computer or simulator. Fig. 1 contains a musical score captured from one such performance.")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"creating-a-quantum-musical-composition"}},[_vm._v("Creating a quantum musical composition")]),_vm._v(" "),_c(\'p\',[_vm._v("To create a quantum musical composition, the user first supplies the desired probabilities for a given pitch to follow another given pitch "),_c(\'em\',[_vm._v("melodically")]),_vm._v(". Take a moment to examine the music score in Fig. 1 and notice that the staff labeled "),_c(\'strong\',[_vm._v("Melody")]),_vm._v(" contains an eight-note melody. Please also realize that the staff labeled "),_c(\'strong\',[_vm._v("Harmony")]),_vm._v(" actually contains seven four-note melodies.  Users enter their desired probabilities into the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Doubly_stochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("doubly-stochastic matrix")]),_vm._v(" located on the left side of the "),_c(\'strong\',[_vm._v("MELODY MATRICES")]),_vm._v(" tab.")]),_vm._v(" "),_c(\'p\',[_vm._v("Clicking the "),_c(\'strong\',[_vm._v("Optimize Rotations")]),_vm._v(" button updates the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Orthogonal_matrix","target":"_blank","rel":"noopener"}},[_vm._v("orthogonal matrix")]),_vm._v(" on the right to contain values, that when squared, comprise a "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Unistochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("unistochastic matrix")]),_vm._v(" that approximates the user\'s desired probabilities. Deselecting and selecting the "),_c(\'strong\',[_vm._v("Show Probabilities")]),_vm._v(" checkbox toggles between showing the orthogonal matrix and the unistochastic matrix, respectively. The application optimizes the unistochastic matrix by gradually changing the angles of the six degree-of-freedom rotations in four-dimensional vector space until the difference between the doubly-stochastic matrix and the unistochastic matrix is minimized.  You can experiment with the effects of each rotation on the matrix on the right by using the sliders in the "),_c(\'strong\',[_vm._v("Degree of Freedom Rotations")]),_vm._v(" region of this tab. Each slider has the range "),_c(\'img\',{attrs:{"src":"docimages/eqn_range_0_pi2.gif","alt":"eqn_range_0_pi2"}}),_vm._v(" radians.")]),_vm._v(" "),_c(\'p\',[_vm._v("To continue creating the quantum musical composition, the user supplies the desired probabilities for a given pitch to be played "),_c(\'em\',[_vm._v("harmonically")]),_vm._v(" with another given pitch. Take another moment to examine the musical score in Fig. 1 and notice that each of the notes in the staff labeled "),_c(\'strong\',[_vm._v("Melody")]),_vm._v(" have a note in the staff labeled "),_c(\'strong\',[_vm._v("Harmony")]),_vm._v(" directly above it. Users enter their desired probabilities into the "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Doubly_stochastic_matrix","target":"_blank","rel":"noopener"}},[_vm._v("doubly-stochastic matrix")]),_vm._v(" located on the left side of the "),_c(\'strong\',[_vm._v("HARMONY MATRICES")]),_vm._v(" tab, and then click the "),_c(\'strong\',[_vm._v("Optimize Rotations")]),_vm._v(" button.")]),_vm._v(" "),_c(\'p\',[_vm._v("The harmonic probabilities entered will apply to all of the notes played harmonically in the performance except for the final note on each staff, as those two notes will have the same "),_c(\'a\',{attrs:{"href":"https://en.wikipedia.org/wiki/Pitch_class","target":"_blank","rel":"noopener"}},[_vm._v("pitch class")]),_vm._v(" as the first note in the melody staff. These notes provide a sense of resolution and finality to the performance, and are the only two notes in the performance that aren\'t determined by the quantum computer.")])]) }]',component:{data:{},render:{},created:{}}}}}),Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:"In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself [here](https://maddytod.trinket.io/sites/tictacq)! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.\n\n## The Modes\nThe idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.\n\n\n### Basic\nThis mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+> state, apply gates based on how \"good\" the move is to encourage it towards the |-> state and then reapply the `H` gate so the vector moves to be nearer to |0> or |1> depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.\n\nThe circuit is created as follows :\n1. Any spaces that have a move already in them have an `X` gate applied to them. This means that they cannot possibly be used a move.\n2. Every available space has an `H` gate applied to it to take it into the equal superposition.\n3. All the spaces that are available are iterated over and have T gates applied to then according to some rules.\n    * Apply one `T` gate for every move in the same column as the space\n    * Apply one `T` gate for every move in the same row as the space\n    * Apply one `S` gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal\n4. Apply an `H` gate to all the available spaces.\n\nWe then run this circuit 100 times and get the counts. These are then processed so that the counts of 1's in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.\n\nAll of this can be visualized using the Bloch Sphere by clicking the `Show setup states button`, or if you would like to skip straight to the end states the button `Show final states` can be clicked.\n\n\n### Grover\n*Note: This player takes a long time to run, due to the fact it runs Grover's algorithm locally*\n\nThis player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the [wikiHow](https://www.wikihow.com/Win-at-Tic-Tac-Toe) page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover's algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.\n\n\n### SVM\n\nThis method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.\n\nThe `Show classical view` button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the `Show quantum view button`. Note how if you don't play in the top row, the view for the quantum computer doesn't change, but when you do it changes it's view. It is also possible that it suggests to play in a space that is already taken, this is because it can't see that there is a move there! If this occurs the player will just choose a random space to play in.\n\n\n\n\nHappy playing!\n",html:'<p>In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself <a href="https://maddytod.trinket.io/sites/tictacq" target="_blank" rel="noopener">here</a>! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.</p>\n<h2 id="the-modes">The Modes</h2>\n<p>The idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.</p>\n<h3 id="basic">Basic</h3>\n<p>This mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+&gt; state, apply gates based on how &quot;good&quot; the move is to encourage it towards the |-&gt; state and then reapply the <code>H</code> gate so the vector moves to be nearer to |0&gt; or |1&gt; depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.</p>\n<p>The circuit is created as follows :</p>\n<ol>\n<li>Any spaces that have a move already in them have an <code>X</code> gate applied to them. This means that they cannot possibly be used a move.</li>\n<li>Every available space has an <code>H</code> gate applied to it to take it into the equal superposition.</li>\n<li>All the spaces that are available are iterated over and have T gates applied to then according to some rules.\n<ul>\n<li>Apply one <code>T</code> gate for every move in the same column as the space</li>\n<li>Apply one <code>T</code> gate for every move in the same row as the space</li>\n<li>Apply one <code>S</code> gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal</li>\n</ul>\n</li>\n<li>Apply an <code>H</code> gate to all the available spaces.</li>\n</ol>\n<p>We then run this circuit 100 times and get the counts. These are then processed so that the counts of 1\'s in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.</p>\n<p>All of this can be visualized using the Bloch Sphere by clicking the <code>Show setup states button</code>, or if you would like to skip straight to the end states the button <code>Show final states</code> can be clicked.</p>\n<h3 id="grover">Grover</h3>\n<p><em>Note: This player takes a long time to run, due to the fact it runs Grover\'s algorithm locally</em></p>\n<p>This player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the <a href="https://www.wikihow.com/Win-at-Tic-Tac-Toe" target="_blank" rel="noopener">wikiHow</a> page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover\'s algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.</p>\n<h3 id="svm">SVM</h3>\n<p>This method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.</p>\n<p>The <code>Show classical view</code> button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the <code>Show quantum view button</code>. Note how if you don\'t play in the top row, the view for the quantum computer doesn\'t change, but when you do it changes it\'s view. It is also possible that it suggests to play in a space that is already taken, this is because it can\'t see that there is a move there! If this occurs the player will just choose a random space to play in.</p>\n<p>Happy playing!</p>\n',attributes:{title:"TicTacQ",author:"Maddy Tod",description:"Play TicTacToe against a quantum computer, which can use 3 different strategies to try and win.",image:"/images/experiments/tictacq/basic-player.png",to:"/experiments/tictacq",media:["/images/experiments/tictacq/basic-player.png","/images/experiments/tictacq/grover-player.png","/images/experiments/tictacq/svm-player.png"],source:"https://github.com/maddy-tod/tictactoe-roli",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/tictacq.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself "),_c(\'a\',{attrs:{"href":"https://maddytod.trinket.io/sites/tictacq","target":"_blank","rel":"noopener"}},[_vm._v("here")]),_vm._v("! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"the-modes"}},[_vm._v("The Modes")]),_vm._v(" "),_c(\'p\',[_vm._v("The idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"basic"}},[_vm._v("Basic")]),_vm._v(" "),_c(\'p\',[_vm._v("This mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+> state, apply gates based on how \\"good\\" the move is to encourage it towards the |-> state and then reapply the "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate so the vector moves to be nearer to |0> or |1> depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.")]),_vm._v(" "),_c(\'p\',[_vm._v("The circuit is created as follows :")]),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("Any spaces that have a move already in them have an "),_c(\'code\',{pre:true},[_vm._v("X")]),_vm._v(" gate applied to them. This means that they cannot possibly be used a move.")]),_vm._v(" "),_c(\'li\',[_vm._v("Every available space has an "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate applied to it to take it into the equal superposition.")]),_vm._v(" "),_c(\'li\',[_vm._v("All the spaces that are available are iterated over and have T gates applied to then according to some rules.\\n"),_c(\'ul\',[_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("T")]),_vm._v(" gate for every move in the same column as the space")]),_vm._v(" "),_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("T")]),_vm._v(" gate for every move in the same row as the space")]),_vm._v(" "),_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("S")]),_vm._v(" gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal")])])]),_vm._v(" "),_c(\'li\',[_vm._v("Apply an "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate to all the available spaces.")])]),_vm._v(" "),_c(\'p\',[_vm._v("We then run this circuit 100 times and get the counts. These are then processed so that the counts of 1\'s in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.")]),_vm._v(" "),_c(\'p\',[_vm._v("All of this can be visualized using the Bloch Sphere by clicking the "),_c(\'code\',{pre:true},[_vm._v("Show setup states button")]),_vm._v(", or if you would like to skip straight to the end states the button "),_c(\'code\',{pre:true},[_vm._v("Show final states")]),_vm._v(" can be clicked.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"grover"}},[_vm._v("Grover")]),_vm._v(" "),_c(\'p\',[_c(\'em\',[_vm._v("Note: This player takes a long time to run, due to the fact it runs Grover\'s algorithm locally")])]),_vm._v(" "),_c(\'p\',[_vm._v("This player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the "),_c(\'a\',{attrs:{"href":"https://www.wikihow.com/Win-at-Tic-Tac-Toe","target":"_blank","rel":"noopener"}},[_vm._v("wikiHow")]),_vm._v(" page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover\'s algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"svm"}},[_vm._v("SVM")]),_vm._v(" "),_c(\'p\',[_vm._v("This method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.")]),_vm._v(" "),_c(\'p\',[_vm._v("The "),_c(\'code\',{pre:true},[_vm._v("Show classical view")]),_vm._v(" button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the "),_c(\'code\',{pre:true},[_vm._v("Show quantum view button")]),_vm._v(". Note how if you don\'t play in the top row, the view for the quantum computer doesn\'t change, but when you do it changes it\'s view. It is also possible that it suggests to play in a space that is already taken, this is because it can\'t see that there is a move there! If this occurs the player will just choose a random space to play in.")]),_vm._v(" "),_c(\'p\',[_vm._v("Happy playing!")])]) }]',component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:"In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself [here](https://maddytod.trinket.io/sites/tictacq)! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.\n\n## The Modes\nThe idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.\n\n\n### Basic\nThis mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+> state, apply gates based on how \"good\" the move is to encourage it towards the |-> state and then reapply the `H` gate so the vector moves to be nearer to |0> or |1> depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.\n\nThe circuit is created as follows :\n1. Any spaces that have a move already in them have an `X` gate applied to them. This means that they cannot possibly be used a move.\n2. Every available space has an `H` gate applied to it to take it into the equal superposition.\n3. All the spaces that are available are iterated over and have T gates applied to then according to some rules.\n    * Apply one `T` gate for every move in the same column as the space\n    * Apply one `T` gate for every move in the same row as the space\n    * Apply one `S` gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal\n4. Apply an `H` gate to all the available spaces.\n\nWe then run this circuit 100 times and get the counts. These are then processed so that the counts of 1's in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.\n\nAll of this can be visualized using the Bloch Sphere by clicking the `Show setup states button`, or if you would like to skip straight to the end states the button `Show final states` can be clicked.\n\n\n### Grover\n*Note: This player takes a long time to run, due to the fact it runs Grover's algorithm locally*\n\nThis player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the [wikiHow](https://www.wikihow.com/Win-at-Tic-Tac-Toe) page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover's algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.\n\n\n### SVM\n\nThis method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.\n\nThe `Show classical view` button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the `Show quantum view button`. Note how if you don't play in the top row, the view for the quantum computer doesn't change, but when you do it changes it's view. It is also possible that it suggests to play in a space that is already taken, this is because it can't see that there is a move there! If this occurs the player will just choose a random space to play in.\n\n\n\n\nHappy playing!\n"},html:{writable:!0,enumerable:!0,value:'<p>In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself <a href="https://maddytod.trinket.io/sites/tictacq" target="_blank" rel="noopener">here</a>! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.</p>\n<h2 id="the-modes">The Modes</h2>\n<p>The idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.</p>\n<h3 id="basic">Basic</h3>\n<p>This mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+&gt; state, apply gates based on how &quot;good&quot; the move is to encourage it towards the |-&gt; state and then reapply the <code>H</code> gate so the vector moves to be nearer to |0&gt; or |1&gt; depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.</p>\n<p>The circuit is created as follows :</p>\n<ol>\n<li>Any spaces that have a move already in them have an <code>X</code> gate applied to them. This means that they cannot possibly be used a move.</li>\n<li>Every available space has an <code>H</code> gate applied to it to take it into the equal superposition.</li>\n<li>All the spaces that are available are iterated over and have T gates applied to then according to some rules.\n<ul>\n<li>Apply one <code>T</code> gate for every move in the same column as the space</li>\n<li>Apply one <code>T</code> gate for every move in the same row as the space</li>\n<li>Apply one <code>S</code> gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal</li>\n</ul>\n</li>\n<li>Apply an <code>H</code> gate to all the available spaces.</li>\n</ol>\n<p>We then run this circuit 100 times and get the counts. These are then processed so that the counts of 1\'s in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.</p>\n<p>All of this can be visualized using the Bloch Sphere by clicking the <code>Show setup states button</code>, or if you would like to skip straight to the end states the button <code>Show final states</code> can be clicked.</p>\n<h3 id="grover">Grover</h3>\n<p><em>Note: This player takes a long time to run, due to the fact it runs Grover\'s algorithm locally</em></p>\n<p>This player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the <a href="https://www.wikihow.com/Win-at-Tic-Tac-Toe" target="_blank" rel="noopener">wikiHow</a> page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover\'s algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.</p>\n<h3 id="svm">SVM</h3>\n<p>This method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.</p>\n<p>The <code>Show classical view</code> button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the <code>Show quantum view button</code>. Note how if you don\'t play in the top row, the view for the quantum computer doesn\'t change, but when you do it changes it\'s view. It is also possible that it suggests to play in a space that is already taken, this is because it can\'t see that there is a move there! If this occurs the player will just choose a random space to play in.</p>\n<p>Happy playing!</p>\n'},attributes:{writable:!0,enumerable:!0,value:{title:"TicTacQ",author:"Maddy Tod",description:"Play TicTacToe against a quantum computer, which can use 3 different strategies to try and win.",image:"/images/experiments/tictacq/basic-player.png",to:"/experiments/tictacq",media:["/images/experiments/tictacq/basic-player.png","/images/experiments/tictacq/grover-player.png","/images/experiments/tictacq/svm-player.png"],source:"https://github.com/maddy-tod/tictactoe-roli",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/tictacq.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"content"},[_c(\'p\',[_vm._v("In this experiment you can play noughts and crosses against a real quantum computer! Try it our for yourself "),_c(\'a\',{attrs:{"href":"https://maddytod.trinket.io/sites/tictacq","target":"_blank","rel":"noopener"}},[_vm._v("here")]),_vm._v("! You can also edit the code to come up with new better strategies for the quantum computer to play as. The stragies that are currently implemented are explained below.")]),_vm._v(" "),_c(\'h2\',{attrs:{"id":"the-modes"}},[_vm._v("The Modes")]),_vm._v(" "),_c(\'p\',[_vm._v("The idea behind the different players is that they demonstrate the different way quantum computing can currently be used. The Basic player demonstrates the low level ways quantum computers can be used, literally at the gate level. The Grover player exhibits an inherently quantum algorithm and the SVM player uses a hybrid, quantum and classical strategy to play.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"basic"}},[_vm._v("Basic")]),_vm._v(" "),_c(\'p\',[_vm._v("This mode creates a new circuit every time the computer needs to make a move. The circuit consists of 9 qubits, one for each space on the board. The general premise of circuit creation is to put all potential moves into an equal superposition, so in the |+> state, apply gates based on how \\"good\\" the move is to encourage it towards the |-> state and then reapply the "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate so the vector moves to be nearer to |0> or |1> depending on how good the move was considered to be. The more likely a qubit is to be measured as a 1, the better the move.")]),_vm._v(" "),_c(\'p\',[_vm._v("The circuit is created as follows :")]),_vm._v(" "),_c(\'ol\',[_c(\'li\',[_vm._v("Any spaces that have a move already in them have an "),_c(\'code\',{pre:true},[_vm._v("X")]),_vm._v(" gate applied to them. This means that they cannot possibly be used a move.")]),_vm._v(" "),_c(\'li\',[_vm._v("Every available space has an "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate applied to it to take it into the equal superposition.")]),_vm._v(" "),_c(\'li\',[_vm._v("All the spaces that are available are iterated over and have T gates applied to then according to some rules.\\n"),_c(\'ul\',[_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("T")]),_vm._v(" gate for every move in the same column as the space")]),_vm._v(" "),_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("T")]),_vm._v(" gate for every move in the same row as the space")]),_vm._v(" "),_c(\'li\',[_vm._v("Apply one "),_c(\'code\',{pre:true},[_vm._v("S")]),_vm._v(" gate if the space is on a diagonal and there are 2 occupied spaces on the same diagonal")])])]),_vm._v(" "),_c(\'li\',[_vm._v("Apply an "),_c(\'code\',{pre:true},[_vm._v("H")]),_vm._v(" gate to all the available spaces.")])]),_vm._v(" "),_c(\'p\',[_vm._v("We then run this circuit 100 times and get the counts. These are then processed so that the counts of 1\'s in each position are obtained. The one that is the maximum is then selected as the move the quantum computer should make.")]),_vm._v(" "),_c(\'p\',[_vm._v("All of this can be visualized using the Bloch Sphere by clicking the "),_c(\'code\',{pre:true},[_vm._v("Show setup states button")]),_vm._v(", or if you would like to skip straight to the end states the button "),_c(\'code\',{pre:true},[_vm._v("Show final states")]),_vm._v(" can be clicked.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"grover"}},[_vm._v("Grover")]),_vm._v(" "),_c(\'p\',[_c(\'em\',[_vm._v("Note: This player takes a long time to run, due to the fact it runs Grover\'s algorithm locally")])]),_vm._v(" "),_c(\'p\',[_vm._v("This player chooses its moves by using Grovers algorithm. It creates a SAT oracle based on the current state of the board and a set of predefined rules. The rules are extracted from the "),_c(\'a\',{attrs:{"href":"https://www.wikihow.com/Win-at-Tic-Tac-Toe","target":"_blank","rel":"noopener"}},[_vm._v("wikiHow")]),_vm._v(" page on how to win noughts and crosses! The set of rules then have all the current moves appended as negated variables. This is then run through Grover\'s algorithm and a valid solution is returned. All the variables that are positive literals in the returned solution are potential moves. These are not necessarily the best moves, just potential valid ones. We then select the move from this list based on more of the advice from the article : if 5 (the number corresponding to the central space)is returned then take that space, else if there is a corner move take that, else choose randomly.")]),_vm._v(" "),_c(\'h3\',{attrs:{"id":"svm"}},[_vm._v("SVM")]),_vm._v(" "),_c(\'p\',[_vm._v("This method uses the SVM provided by Qiskit Aqua to select its next move. This classifier is trained on a lots of data about different board configurations and where the next move should be played, which is indicated by the classification on the end.")]),_vm._v(" "),_c(\'p\',[_vm._v("The "),_c(\'code\',{pre:true},[_vm._v("Show classical view")]),_vm._v(" button shows which move based on looking at all the data the computer should make. It is called this because classical hardware is currently more advanced, and so it can process all the data. The quantum computer however has to perform PCA, which means it can only see 3 features of the dataset. This is the same as only being able to see the top row of the board. This introduces a lot more uncertainty about where the move should be played, which can be visualised by clicking the "),_c(\'code\',{pre:true},[_vm._v("Show quantum view button")]),_vm._v(". Note how if you don\'t play in the top row, the view for the quantum computer doesn\'t change, but when you do it changes it\'s view. It is also possible that it suggests to play in a space that is already taken, this is because it can\'t see that there is a move there! If this occurs the player will just choose a random space to play in.")]),_vm._v(" "),_c(\'p\',[_vm._v("Happy playing!")])]) }]',component:{data:{},render:{},created:{}}}}}),Object.create(null,{default:{writable:!0,enumerable:!0,value:{body:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\n\n",html:"<p>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description</p>\n",attributes:{title:"Qiskit Blocks",author:"James Weaver",description:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.",image:"https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png",to:"/experiments/qiskit-blocks",media:["https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png","/images/experiments/qiskit-blocks/quantum_cats_sandbox.png"],source:"https://github.com/JavaFXpert/QiskitBlocks",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qiskit-blocks.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:"return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('p',[_vm._v(\"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\")])]) }]",component:{data:{},render:{},created:{}}}}},body:{writable:!0,enumerable:!0,value:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\n\n"},html:{writable:!0,enumerable:!0,value:"<p>The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description</p>\n"},attributes:{writable:!0,enumerable:!0,value:{title:"Qiskit Blocks",author:"James Weaver",description:"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world.",image:"https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png",to:"/experiments/qiskit-blocks",media:["https://github.com/JavaFXpert/QiskitBlocks/raw/master/quantum_circuits_garden.png","/images/experiments/qiskit-blocks/quantum_cats_sandbox.png"],source:"https://github.com/JavaFXpert/QiskitBlocks",_meta:{resourcePath:"/home/travis/build/qiskit-community/community.qiskit.org/content/experiments/qiskit-blocks.md"}}},vue:{writable:!0,enumerable:!0,value:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:"return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('p',[_vm._v(\"The QiskitBlocks application teaches quantum computing concepts using Qiskit, in the context of a Minetest block world. TODO: Add more description\")])]) }]",component:{data:{},render:{},created:{}}}}})]}}]}],error:null,serverRendered:!0}}("experiments/")</script><script src="/_nuxt/e4a6c8f96de9b22b1fd1.js" defer></script><script src="/_nuxt/f4970d7ed49cd7da99d4.js" defer></script><script src="/_nuxt/53e5ca4e26d8f84797b2.js" defer></script><script src="/_nuxt/33a95c28e8058ed027ee.js" defer></script><script src="/_nuxt/6c5b5dda30dfc24b2273.js" defer></script>
  </body>
</html>
